高并发问题：

##### 1. 为啥需要高并发：

刚开始系统都是连接数据库的，但是要知道数据库支撑到每秒并发两三千的时候，基本就快完了。

你数据库如果瞬间承载每秒 5000/8000，甚至上万的并发，一定会宕机，因为比如 mysql 就压根儿扛不住这么高的并发量。



##### 2. 解决高并发：

可以分为以下 6 点：

- 系统拆分
- 缓存
- MQ
- 分库分表
- 读写分离
- ElasticSearch



**系统拆分**

将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。



**缓存**

缓存，必须得用缓存。大部分的高并发场景，都是**读多写少**，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的**读场景，怎么用缓存来抗高并发**。



**MQ**

MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费后慢慢写，控制在 mysql 承载范围之内。



**分库分表**

分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表**拆分为多个表**，每个表的数据量保持少一点，提高 sql 跑的性能。



**读写分离**

读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，**主库写**入，**从库读**取，搞一个读写分离。**读流量太多**的时候，还可以**加更多的从库**。



高并发请求核心要素则是必须保证大量请求高可用，一致性，高性能。



**如何保证高性能呢？**

客户层可以采用用户答题和输入验证码等方法，限制请求次数，防止0点秒杀的时刻，峰值全部集中在一起，这样最主要是可以防止有人作弊秒杀，而且也可以延缓客户请求，把请求分布在不同的时间段。

业务层可以限制接口的调用次数。

也可以采用流量削峰来实现，如今已经有大量优秀的开源框架支撑流量削峰功能，如RabbitMq和kafka等。RabbitMq的消息队列除了有解耦和异步的功能外，还可以实现流量削峰，将大量用户请求先存储在mq队列中，之后就可以分摊在其他时间段进入数据库。



**如何实现高可用？**

最后，为了保证服务器的高可用，肯定是需要部署在多个服务器上保证其中一个宕机，系统还能正常运行。



**拒绝请求**

当服务降级和服务限流不能解决的情况下，最后就只能返回一个错误页面给用户，比如“用户请求过多”“服务繁忙，稍后再试”等，只会发生在服务器过载时候启用，只会存在短暂不可用情况，一旦正常运行的服务器负载降下来，则可以正常请求。











































































