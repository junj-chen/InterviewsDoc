##### 1. 事务

事务是指对数据库中的一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。



##### 2. 事务的特性

1. 原子性（Atomicity）：指事务包含的所有操作要么全部成功，要么回滚失败，因此，提交成功将所有的操作全部应用到数据库，回滚则所有操作对数据库没有影响
2. 一致性（Consistency）：事务开始前后，数据库的完整性约束没有被破坏
3. 隔离性（Isolation）：当多个用户并发的访问数据库时，数据库为每一个用户开启的事务对其他事务没有干扰，多个并发事务之间互相隔离。
4. 持久性（Durability）：持久性是指一个事务一旦提交了，那么对数据库中的数据的改变就是永久性的，即使遇到故障也不会丢失事务已经提交的操作



##### 3.  事务的实现

​	事务是 InnoDB 引擎中具有的特性，事务的实现与 InnoDB 提供的两种日志相关，redo log（重做日志） 和 undo log(回滚日志)，其中 **redo log用于保证事务的持久性**， **undo log可以保证事务的原子性和隔离性**

**逻辑日志和物理日志的区别**
看记日志的时候 是针对一行记录，就是逻辑日志 如果是一个数据页，就是物理日志

**原子性**的实现

 1. undo log : undo log是实现原子性的关键，当事务回滚的时候可以撤销所有已经成功执行的sql语句。

    undo log是逻辑日志，他记录了mysql执行的相关信息，比如每个 事务的 insert，回滚执行 delete，执行 update ，回滚会执行一个相反的update，把数据修改回去。

    

**持久性**的实现

持久性的定义：事务一旦提交，其所作做的修改会永久保存到数据库中，此时即使系统崩溃修改的数据也不会丢失。

实现原理：Redo log， 用于存储数据页的改变，保证 crash-safe，bin log 与 redo log的两阶段提交 （**两阶段提交**）



**隔离性**的实现：

隔离性的定义：隔离性研究的是不同事务之间的相互影响。隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

隔离性的探讨主要分为了两个部分：

一个事务写操作对另一个事务的写操作的影响：根据锁机制保证隔离性

一个事务写操作对另一个事务的读操作的影响：MVCC机制保证隔离性

在事务并发中，存在的三个问题：

	1. 脏读： 当前事务（A）可以读取到其他事务(B)没有提交的事务，就是脏读
 	2. 不可重复读：在事务(A)中先后读取同一个数据，两次读取的结果不一样，第一次读取时B事务没有提交，第二次读取时B事务已经提交，也就是不可重复读
 	3. 幻读：事务A两次查询数据库时，查询结果的条数不同，这就是幻读，

不可重复读与幻读的区别：不可重复读是同一个数据发生了变化，幻读是数据的行数发生了变化



事务的隔离级别写解决的问题：

<img src="C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20210805194258464.png" alt="image-20210805194258464" style="zoom:80%;" />



**Mysql的可重复读的隔离级别**就可以解决 幻读、不可重复读、脏读等问题，使用的是MVCC（多版本并发控制协议）

MVCC：在同一时刻下，不同的事务读取到的数据可能是不同的（多版本），多个版本的数据可以共存

MVCC最大的优点是读不加锁，因此读写不冲突，并发性能好，主要是依靠数据的隐藏列和undo log，隐藏列包含了该行数据的版本号、删除时间、执行undo log的指针等，当读取数据时，MYSQL 可以通过隐藏列判断是否需要回滚并找到回滚需要的 undo log，从而实现 MVCC。

简介MVCC通过版本号实现 数据的隔离性，每行数据的隐藏列中都一个版本号，版本号是严格自增的，当一个事务启动的时候，每个事务会获取一个版本号，当操作的时候会去查询当前数据的版本号与自己获取的数据版本号对比，如果大于自己第一次获取的版本号，就需要通过 undo log进行回滚找到自己可以操作的版本号进行操作，从而实现事务的隔离性。



幻读：InnoDB 实现的 RR 是通过 next-key lock 机制避免了幻读现象 

next-key lock 是行锁的一部分，实现相当于 record lock（记录锁） + gap lock（间隙锁），其特点是不仅仅会锁住记录本身（record lock），还会锁定一个范围（gap lock）的功能。当然，这里我们讨论的是不加锁读：此时的next-key lock并不是真的加锁，只是为读取的数据增加了标记（标记内容包括数据的版本号等）；



**一致性**

一致性定义：一致性是指事务执行结束后，**数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。**

一致性的实现：

实现一致性的措施包括：

- 保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证
- 数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等
- 应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致性



参考：https://www.jianshu.com/p/bcbeb58963c3













































实验部分： 事务的隔离性（）

步骤1 设置两个事务的隔离级别 为 RR

![image-20210805165655242](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20210805165655242.png)		![image-20210805165742258](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20210805165742258.png)



数据的原始值：

![image-20210805170258951](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20210805170258951.png)

步骤：当事务的隔离级别为 **RR** 的情况下：

| 时间 | 事务1                                              | 事务2                                    |
| ---- | -------------------------------------------------- | ---------------------------------------- |
| 1    | 开启事务                                           | 开启事务                                 |
|      |                                                    | 修改 ID= 100的 k 的值，由 123 修改为 100 |
|      | 查询 ID = 100，k的值  **（查询得到的值为 123）**   |                                          |
|      |                                                    | 提交事务                                 |
|      | 查询 ID = 100，k的值  **（查询得到的值为 123）**   |                                          |
|      | 提交事务                                           |                                          |
|      | ，查询 ID = 100，k的值  **（查询得到的值为 100）** |                                          |









 修改 隔离级别进行操作

（set session transaction isolation level read committed;）

<img src="C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20210805172009821.png" style="zoom:70%;" />









































































































