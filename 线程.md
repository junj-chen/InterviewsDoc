进程和线程的区别？

1. 进程拥有独立的堆栈空间和数据段，系统开销比较大，线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高
2. 进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。
3. 通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便
4. 属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。
5. 线程又称为轻量级进程，进程有进程控制块，线程有线程控制块；
6. 线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；



进程与线程的选择取决以下几点：

1. 需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。
2. 线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应
3. 因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；
4. 并行操作时使用线程，如C/S[架构](http://lib.csdn.net/base/architecture)的服务器端并发线程响应用户的请求；
5. 需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。



Redis 与 IO多路复用

**Redis 服务采用 Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）**

![img](https://pic1.zhimg.com/80/v2-6e62c72972e3823b7cb82ff768e1d430_720w.jpg)



文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。

虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。



**单线程模型每秒万级别处理能力的原因**
（1）**纯内存访问。** 数据存放在内存中，内存的响应时间大约是 **100纳秒** ，这是Redis每秒万亿级别访问的重要基础。

（2）**非阻塞I/O** ，**Redis采用epoll做为I/O多路复用技术的实现** ，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间。

（3）单线程 **避免了线程切换和竞态产生的消耗** 。

（4）Redis采用单线程模型，**每条命令执行如果占用大量时间，** 会造成其他线程阻塞，对于Redis这种高性能服务是致命的，所以Redis是面向高速执行的数据库。





### epoll模型的特点：

（1）本身没有最大并发连接的限制，仅受系统中进程能打开的最大文件数目限制。

（2）基于事件就绪通知方式：一旦被监听的某个文件描述符就绪，内核会采用类似于callback的回调机制，迅速激活这个文件描述符，这样随着文件描述符数量的增加，也不会影响判定就绪的性能。不会像select/poll中轮询检测每个描述符是否就绪。

（3）当文件描述符就绪，就会被放到一个数组中，这样调用epoll_weit获取就绪文件描述符的时候，只要取数组中的返回的个数个元素即可，不需要全部做轮询检测。

（4）内存拷贝是利用mmap()文件映射内存的方式加速与内核空间的消息传递，减少复制开销。（内核与用户空间共享一块内存）



### epoll工作模式

epoll对文件描述符的操作有两种模式：水平触发LT（level trigger）和边缘触发ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：

LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。 

ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。



ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。

epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。



































































































































