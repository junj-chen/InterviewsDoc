### 1. OSI  七层与 TCP/IP四层关系与区别

![image-20210803144733667](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20210803144733667.png)

**特点：**

- 层与层之间相互独立又相互依靠
- 上层依赖于下层，下层为上层提供服务



### 2. TCP 与 UDP的区别？

|              | TCP                            | UDP                                |
| :----------- | ------------------------------ | ---------------------------------- |
| 是否面向连接 | 面向连接                       | 面向无连接                         |
| 是否可靠     | 可靠传输                       | 不可靠传输                         |
| 连接对象个数 | 一对一连接                     | 一对一、一对多、多对一、多对多通信 |
| 传输方式     | 面向字节流                     | 面向报文                           |
| 适用场景     | 适用于可靠的传输，文件传输等   | 适用于实时传输                     |
| 首部开销     | 首部最下 20 字节，最大 60 字节 | 仅为 8 字节                        |



### 3.  TCP如何保证可靠传输的？

1. 计算校验和， 在发送端将发送数据计算校验和发送，接收端接收到数据同样的方式计算校验和进行验证

2. 发送端数据都进行序列号编码，除了应答确认，还可以进行排序，保证数据的完整性

3. 确认应答，TCP传输中，接收方收到数据后会发送ACK确认号，告诉发送方接收到了那些数据，下一次从哪里发送数据

4. 超时重传，发送数据后，需要等待ACK报文，判断数据是否发送成功，超时后需要对发送的数据重新发送

5. 管理连接，TCP三次握手，四次挥手

6. 流量控制，发送方速度太快，接收方将自身缓冲区大小放入TCP首部中，告诉发送端，控制发送速度

7. 拥塞控制，网络拥塞的情况，TCP会引入慢启动机制

   

### 4.  TCP协议如何提高传输效率？

​	TCP 是通过滑动窗口、延迟应答、捎带应答、快重传提高效率

1. 滑动窗口

   如果每一个发送的数据段，都要收到 ACK 应答之后再发送下一个数据段，这样的话我们效率很低，大部分时间都用在了等待 ACK 应答上了。为了提高效率我们可以一次发送多条数据，这样就能使等待时间大大减少，从而提高性能。窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。

2. 捎带应答

   在延迟应答的基础上，很多情况下，客户端服务器在应用层也是一发一收的。这时候常常采用捎带应答的方式来提高效率，而ACK响应常常伴随着数据报文共同传输。

   

### 5. TCP如何处理拥塞？

	1. 慢启动，刚开始，指数的形式增大发送的数据量
 	2. 拥塞控制，达到窗口值，每次+1线性的增长数据量
 	3. 快重传：快重传要求接收方在收到一个 **失序的报文段** 后就立即发出 **重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
 	4. 快恢复： 快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。





### 6. 讲一下三次握手和四次挥手全过程

三次握手：

![image-20210803151721748](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20210803151721748.png)

采用C/S模式解释，假设C端发起传输请求。

在发送建立链接请求之前，C端是保持CLOSED状态，S端最开始也是处于CLOSED状态，当执行listen函数套接字进入**被动监听状态**。

所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。

第一次：C端发送SYN=1的请求报文，此时C端进入SYN SENT状态，等待服务器确认。

### **此时如果报文丢失发送不到对端会如何？**

> C端发送报文之后会启动一个定时器，在超时之后未收到S端的确认，会再次发送SYN请求，每次尝试的时间会是第一次的二倍，如果总的总尝试时间为75秒，此次建立链接失败。

第二次：S端收到C端发送的SYN报文(建立链接请求)后，S端必须返回确认号并且同时发送一条SYN报文，此时进入SYN RCVD状态。

### **为啥要连带发送SYN报文？**

> TCP是全双工通信，协议规定当收到建立链接请求后必须返回序列号，同时建立本端到对端的通信链接。这也叫做捎带应答机制。

### **如果第二次报文丢失怎么办？**

> 在发送完ACK+SYN报文后会启动一个定时器，超时没有收到ACK确认，会再次发送，会进行多次重试。超时时间依旧每次翻倍，重试次数可设置。
> 修改 `/proc/sys/net/ipv4/tcp_synack_retries` 的值

第三次：C端收到S端发的ACK+SYN报文，需要返回一个应答ACK的报文，此时该连接会进入半连接状态的队列，当S端收到ACK后，一条完整的全双工TCP链接建立完成，双方进入ESTABLISHED状态。

> 这里有个常用攻击手段，攻击者伪造一个SYN请求发送给服务端，服务端响应之后，会收不到C端的ACK确认，服务端会不断的重试，默认会重试五次。
> 此时服务端会维持这个链接的所有资源，如果有大量这样的请求，服务端的资源会被耗完。
> 这就是DOS攻击。

### **如果第三次报文丢失怎么办？**

> S端在发出ACK+SYN报文后会启动一个定时器，在超时触发还没收到ACK就确认是丢失了，会重试一次发送。



### listen 时候参数 backlog 的意义？

Linux内核中会维护两个队列：

- 未完成连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；
- 已完成连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS8430Kt5CTsvVQ1mDUje71yzWXvib7sORcicJ97E3aDTtZoNKN41yBTGG0Qg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" style="zoom:50%;" />

```
int listen (int socketfd, int backlog)
```

- 参数一 socketfd 为 socketfd 文件描述符
- 参数二 backlog，这参数在历史有一定的变化

在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。

在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，**所以现在通常认为 backlog 是 accept 队列。**





### 四次挥手：

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843KaMMu2mHfFLZNgiaREDZ5JicRYrlaiciayQjh9HDsacxIbMT0emGUpAX5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" style="zoom:70%;" />

- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSED_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务器收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

你可以看到，每个方向都需要**一个 FIN 和一个 ACK**，因此通常被称为**四次挥手**。

这里一点需要注意是：**主动关闭连接的，才有 TIME_WAIT 状态。**



###### 为什么挥手需要四次？

再来回顾下四次挥手双方发 `FIN` 包的过程，就能理解为什么需要四次了。

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务器收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，从而比三次握手导致多了一次。



###### 为什么 TIME_WAIT 等待的时间是 2MSL？

TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**。

比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。

`2MSL` 的时间是从**客户端接收到 FIN 后发送 ACK 开始计时的**。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 **2MSL 时间将重新计时**。

在 Linux 系统里 `2MSL` 默认是 `60` 秒，那么一个 `MSL` 也就是 `30` 秒。**Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒**。

其定义在 Linux 内核代码里的名称为 TCP_TIMEWAIT_LEN



###### TIME_WAIT 过多有什么危害？

如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器方主动发起的断开请求。

过多的 TIME-WAIT 状态主要的危害有两种：

- 第一是内存资源占用；
- 第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；

第二个危害是会造成严重的后果的，要知道，端口资源也是有限的，一般可以开启的端口为 `32768～61000`，也可以通过如下参数设置指定

```
net.ipv4.ip_local_port_range
```

**如果服务端 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。**



### 7.  为什么 TCP连接需要三次握手，两次不可以么，为什么？

两次握手只能保证单向连接是成功的，只有经过第三次握手才能保证双向接收到对方的发送数据。

“三次握手” 的目的是为了防止**已失效的链接请求报文突然又传送到了服务端**，因而产生错误。



首先我们确定什么是TCP连接：

​	TCP连接是用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口的大小（ RFC 793）

![image-20210831154910359](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20210831154910359.png)

所以重要的是，如何通过三次握手初始化 Socket、序列号和窗口大小并且建立TCP连接。

接下来从三个方面分析三次握手的原因：

	1. 三次握手可以阻止历史重复连接的初始化（主要原因）
 	2. 三次握手可以同步双方的初始化序列号
 	3. 三次握手可以避免资源浪费

###### 原因1：防止旧的重复连接初始化造成混乱

我们来看看 RFC 793 指出的 TCP 连接使用三次握手的**首要原因**：

简单来说，三次握手的**首要原因是为了防止旧的重复连接初始化造成混乱。**

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS8436nKau10lAsztRqbyhjC1C1GRcsEz04icZmomMjwcxgeGn97BnKUoxibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" style="zoom: 50%;" />

客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：

- 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；
- 那么此时服务端就会回一个 `SYN + ACK` 报文给客户端；
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 `RST` 报文给服务端，表示中止这一次连接。

如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：

- 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 `RST` 报文，以此中止历史连接；
- 如果不是历史连接，则第三次发送的报文是 `ACK` 报文，通信双方就会成功建立连接；

所以， TCP 使用三次握手建立连接的最主要原因是**防止历史连接初始化了连接。**



###### *原因2：同步双方初始序列号*

TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：

- 接收方可以去除重复的数据；
- 接收方可以根据数据包的序列号按序接收；
- 可以标识发送出去的数据包中， 哪些是已经被对方收到的；
- <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843HWajXhQQfx6CH4EUxLqib0AAOXolZfIvuoEDkDoXaQ3RIceibo8ia9MQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" style="zoom:70%;" />

四次握手其实也能够可靠的同步双方的初始化序号，但由于**第二步和第三步可以优化成一步**，所以就成了「三次握手」。

而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。



###### *原因3：避免资源浪费*

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843CaTeGEvR5jg3iaHbUTEroayMBUoK3yfy9zGwlIia8pJu8x4RDkDGFLicg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" style="zoom:50%;" />

如果只有「两次握手」，当客户端的 `SYN` 请求连接在网络中阻塞，客户端没有接收到 `ACK` 报文，就会重新发送 `SYN` ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 `ACK` 确认信号，所以每收到一个 `SYN` 就只能先主动建立一个连接，这会造成什么情况呢？

如果客户端的 `SYN` 阻塞了，重复发送多次 `SYN` 报文，那么服务器在收到请求后就会**建立多个冗余的无效链接，造成不必要的资源浪费。**

不使用「两次握手」和「四次握手」的原因：

- 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。



参考:https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247484005&idx=1&sn=cb07ee1c891a7bdd0af3859543190202&chksm=f98e46cfcef9cfd9feb8b9df043a249eb5f226a927fd6d4065e99e62a645a584005d9921541b&scene=178&cur_album_id=1337204681134751744#rd

### 8. SYN攻击

我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的 SYN 接收队列（未连接队列）**，使得服务器不能为正常用户服务。

###### *避免 SYN 攻击 方式一*

其中一种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理，最简单是修改队列（backlog）的接收个数，超出处理能时，对新的 SYN 直接回 RST，丢弃连接



###### *避免 SYN 攻击方式二*

`tcp_syncookies` 的方式可以应对 SYN 攻击的方法：

- 当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；
- 计算出一个 `cookie` 值，再以 SYN + ACK 中的「序列号」返回客户端，
- 服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。
- 最后应用通过调用 `accpet()` socket 接口，从「 Accept 队列」取出的连接。



### 8.  讲一下 http1.1 和 http2 有什么区别？

Http1.0 :

a.长连接

 HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。

b. 请求管道化

c. 增加缓存处理（新的字段如cache-control）

d. 增加 Host 字段、支持断点传输等

Http2.0：

a. 多路复用

 HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。



b. 头部数据压缩

​	在HTTP1.1中，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。

 HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。

c. 服务器推送

​	服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。

 为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。



### 9. 说说 HTTP 和HTTPS 的区别？

（1）HTTPS 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用。

（2）HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。

（3）HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

（4）HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。



### 10. Get与POST的区别

（1）GET 一般用来从服务器上获取资源，POST 一般用来创建资源；

（2）GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的。GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；

（3）从请求参数形式上看，GET 请求的数据会附在`URL之后`；而 POST 请求会把提交的数据则放置在是HTTP请求报文的`请求体`中。

（4）POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而 POST 请求参数则被包装到请求体中，相对更安全。

（5）GET 请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。



### 11. Session、Cookie 的区别

- session 在服务器端，cookie 在客户端（浏览器）
- session 默认被存储在服务器的一个文件里（不是内存）
- session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）
- session 可以放在 文件、数据库、或内存中都可以。
- 用户验证这种场合一般会用 session



### 12. 什么是 XSS 攻击？

XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。XSS的重点不在于跨站点，而在于脚本的执行。

XSS的原理是：

恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。



##### 13. 常见的HTTP方法有哪些？

- GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
- OPTIONS：查询相应URI支持的HTTP方法。



##### 14. SQL注入

SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。



### 15.Http首部

有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。

![image-20210819092812255](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20210819092812255.png)

**请求首部字段**

| Accept     | 用户代理可处理的媒体类型  |
| ---------- | ------------------------- |
| Expect     | 期待服务器的特定行为      |
| User-Agent | HTTP 客户端程序的信息     |
| Host       | 请求资源所在服务器        |
| Range      | 实体的字节范围请求        |
| Referer    | 对请求中 URI 的原始获取方 |



































































































































































































