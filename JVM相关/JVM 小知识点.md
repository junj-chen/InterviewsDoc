JVM 小知识点：

1. new 对象的过程？

当 java虚拟机遇到一个 new 指令的时候，虚拟机首先会检查这个指令的参数能不能在 方法区的常量池中定位到一个**类的符号引用**，并且需要检查这个类是否被加载、解析和初始化。

类加载：

类加载检查通过后，虚拟机会为新创建的对象分配内存，也就是在java的堆空间上分配一块与对象相同大小的空间，分配内存的方式主要有如下两种：

1. 指针碰撞的方式，如果java堆中的空间是规整的，也就是已使用的空间在一边，未使用的空间在另一边，就使用该方式进行堆内存分配，该方式也对应垃圾回收器中的使用压缩整理算法的回收器（Serial 、ParNew）等
2. 空闲列表的方式：如果堆空间的内存不是规整的，虚拟机会维护一个列表表示那些空间可用，那些不可用，通过对该列表进行查找分配空间，该方式也对应使用 清除算法的垃圾回收器（CMS）

内存分配完成后，虚拟机会将分配到的内存空间都初始化为 零，保证了实例字段在java代码中不赋初始值就可以直接使用，使程序可以访问到这些字段的数据类型对应的零值。

最后，虚拟机会设置该对象的部分信息，包括该对象是那个类的实例，对象的哈希码，对象的GC分代年龄信息等，这些信息存储在对象的对象头中。

从虚拟机的角度，对象已经产生，但是从java程序而言，对象只是刚刚创建出来，接下来需要执行init方法，对对象中的资源和信息进行构建（成员变量的赋值等）



2. 对象的内存布局/

对象在堆内存的内存布局主要分为三个部分，对象头，实例数据、对齐填充

   对象头：包括两类信息，第一类是用于存储对象自身的运行时数据，比如哈希码，GC分代年龄、锁状态、线程持有的锁、偏向线程ID等  --- Mark Word 字段。

第二类是类型指针，对象指向他的类型元数据的指针，该指针用来确定该对象是那个类的实例。

实例数据：对象真正存储的有效信息

对齐填充：占位符的作用



3. 内存泄漏/内存溢出？

内存泄漏： 指**无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露**。

内存溢出：指**程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存**，于是就发生了内存溢出。



4. GC Root对象有哪些？

   1. 虚拟机栈中引用的对象，局部变量，临时变量等
   2. 方法区中类静态属性引用的对象，比如java类的静态引用对象
   3. 方法区中的常量引用对象
   4. 本地方法栈中引用的对象
   5. 被同步锁持有的对象

   

5. 方法区回收

   方法区中主要回收两部分内容，包括**废弃的常量**和**不再使用的类**

   1. 废弃的常量：比如字符串常量“java”，和普通对象的可达性分析一样，已经没有其他对象有对他的引用，表示可以回收
   2. 判断一个类型是不是不再使用的类，需要满足一下三点条件;
      1. 该类的实例已经被回收，不存在该类和其子类的所有实例
      2. 该类的类加载已经被回收
      3. 该类对应的 java.lang.Class对象没有在任何地方有引用，也就是无法在任何地方通过反射访问该类的方法

   

   6.安全点？

   再进行可达性分析的过程中，首先需要寻找 GC Root,也就是进行 STW,

   那么在那些地方进行 STW尼？进行STW的地方被称为 安全点，主要是指：

   1. 方法调用结束的位置
   2. 循环跳转的位置
   3. 异常跳转的位置等

   对于安全点，我们需要思考如何保证所有线程都到达了安全点，进行 STW？

   ​	一般有两种方式进行：

   ​	1. 抢占式中断，不需要线程主动配合，当垃圾收集发生时，暂停所有的用户线程，如果发现有线程没有达到安全点，就让该线程继续运行一会达到安全点（该方式没有虚拟机使用）

   ​	2. 主动式中断，不需要直接对线程进行操作，只是设置一个标志位，每一个用户线程在执行过程中会不断的主动轮询该标志位，如果标志位为真就自己在最近的安全点进行主动的中断挂起。

















